1. Diferencia de investigación entre funciones de flecha y funciones regulares: 

R// 

Las funciones de flecha (arrow functions) y las funciones regulares (regular functions) son dos formas distintas de definir funciones en JavaScript. Aquí te presento las principales diferencias entre ellas:
Sintaxis:

Funciones de flecha: Se definen utilizando la sintaxis () => {}. No tienen una palabra clave "function" y usan una flecha (=>) entre los paréntesis y el cuerpo de la función.

Funciones regulares: Se definen utilizando la sintaxis function() {}. Comienzan con la palabra clave "function" seguida del nombre de la función y los paréntesis.

Ejemplo de función de flecha:
javascriptCopy code
const arrowFunction = () => {
  // Código de la función
};

Ejemplo de función regular:
javascriptCopy code
function regularFunction() {
  // Código de la función
}

Contexto "this":
Funciones de flecha: No tienen su propio valor "this". En su lugar, heredan el valor "this" del contexto en el que se encuentran. Esto significa que el "this" dentro de una función de flecha es el mismo que el "this" fuera de la función.
Funciones regulares: Tienen su propio valor "this", que está determinado por cómo se invoca la función. El "this" dentro de una función regular puede variar dependiendo de cómo se llame a la función.
Constructores:
Funciones de flecha: No pueden ser utilizadas como constructores con la palabra clave "new". Intentar usar una función de flecha con "new" generará un error.
Funciones regulares: Pueden ser utilizadas como constructores con la palabra clave "new", lo que permite crear nuevos objetos a partir de ellas.
Argumento "arguments":
Funciones de flecha: No tienen su propio objeto "arguments". Si se intenta acceder al objeto "arguments" dentro de una función de flecha, se referirá al objeto "arguments" del ámbito exterior más cercano que sea una función regular.
Funciones regulares: Tienen su propio objeto "arguments", que contiene los argumentos pasados a la función.
En resumen, las funciones de flecha son una sintaxis más concisa y tienen un comportamiento diferente en cuanto al contexto "this" y la disponibilidad del objeto "arguments". 
Son útiles cuando se desea mantener el valor de "this" del contexto circundante y se busca una función más corta y fácil de leer. Por otro lado, las funciones regulares ofrecen más flexibilidad y pueden usarse como constructores y acceder al objeto "arguments". 
La elección entre una u otra dependerá de los requisitos y el comportamiento deseado en cada caso específico.

2. Crear una nueva función en Tipos regulares y de flecha, que debe recibir un número y se imprimirá en consola si ese numero es ya sea par o impar:

R//

Función regular:
function verificarParImparRegular(numero) {
  if (numero % 2 === 0) {
    console.log(numero + " es un número par.");
  } else {
    console.log(numero + " es un número impar.");
  }
}

Función de flecha:
const verificarParImparFlecha = (numero) => {
  if (numero % 2 === 0) {
    console.log(numero + " es un número par.");
  } else {
    console.log(numero + " es un número impar.");
  }
}

llamar a estas funciones pasando el número que deseas verificar:


verificarParImparRegular(10); // Imprimirá "10 es un número par."
verificarParImparFlecha(15); // Imprimirá "15 es un número impar."

Ambas funciones hacen lo mismo, determinar si el número es par o impar y mostrar un mensaje en la consola en consecuencia. 
La elección entre usar una función regular o de flecha dependerá de tus preferencias y del contexto en el que estés trabajando.


function verificarParImparRegular(numero) {
  if (numero % 2 === 0) {
    console.log(numero + " es un número par.");
  } else {
    console.log(numero + " es un número impar.");
  }
}


const verificarParImparFlecha = (numero) => {
  if (numero % 2 === 0) {
    console.log(numero + " es un número par.");
  } else {
    console.log(numero + " es un número impar.");
  }
}


verificarParImparRegular(120);
verificarParImparFlecha(343); 